Prikazy, ktermi jsme spustil testy:
-----------------------------------
- pri spusteni testu bylo odpojeno vsechno co slo (Internet, nebyla zapnuta zadna dalsi aplikace a
  nic se na pocitaci nedelo)


Zvazit zavyslost na PHP a Jave
	- pokud to pujde lehce, tak aspon pro Windows nezavysle


Minimalne je na Linux zavyslost na Sablotron, Java, Php + xslt.so, /usr/bin/time, xsltproc


Debian ?? (GNU/Linux 6.0.4), 64bit
AMD Opteron(TM) Processor 6234, 2.70GHz -- 132GB

8.4.2012 8:33 martin.malek: 2x12 jader
AMD Opteron(TM) Processor 6234
cpu MHz		: 2700.277
cache size	: 2048 KB
bogomips	: 4799.94
Pamet:
MemTotal: 132025076 kB


POZNAMKY:
---------
* Popsat, ze bud muzu pustit pres instalovane PHP a musim mit nainstalovany php_mbstring.dll
  nebo muzu pres run.bat -- pro Windows.
  Pro Linux musim mit nainstalovane PHP a musi mit tuto extension
	- preci jen zkusit ulozit php do libs i pro linux + extesion mbstring.
* Poznamka, ze by se mohlo pridat vypnuti mereni casu (aby nebylo nutne instalovat /usr/bin/time)
* Problem s normalizaci HTML - mela by se dodelat. Nektere whitespace nejsou signifikantni a nejsou odstraneny.
  V testech mame jen par HTML testu a postaci nam zkontrolovat vystup rucne.
  Pokud by nekdo chtel vytvaret vice HTML testu, musel by rozsirit "controlor.php".
* Poznamka: neprosli jsme vsechny mozne kategorie (slo by zkoumat SVG, OWL, ...). Ale zkoumane kategorie
  byly necim specialni (Docbook - includy, ...). Takze nam to dalo vzdy jine vysledky nez ostatni testy.
* V gitu nechat jen vytvorene sablony testu.
  Vytvorit stranky projektu s pokecem ze to je diplomka, kde bude rozcetnik na
	- popis stroju na jakych to bezelo
	- GitHub
	- odkaz na diplomku
	- odkaz na stranky vedouci
	- odkaz na report testu v HTML
	- odkaz na API dokumentaci
	- ZIP obsahujici
		- /Data/Reports/???.xml
		- /Data/Reports/???.html
		- /Data/Tests/...
		- /Data/TestsTemplates/...
		- /Tmp/... --- asi vcetne absolutni cesty, aby to slo prokliknout ze stranky
		- /log -- log z toho jak jsme pustil testy + na strankach napsat prikaz, kterym jsme to pustil
		- /info -- popis na jakych strojich to bezelo
		- /diplomku
  V logu upravit absolutni cesty na nejae rozumne.
  Zverejnit logy jak pro Windows tak pro Linux.
* V analyze kategorii by slo udelat prozkum namespace, vyskytujicich se v datech a podle toho vybrat dalsi kategorie.
  To uz by bylo ale nad ramec a mohlo by vydat na vlastni praci, protoze kategorii by bylo asi opravdu hodne.
* U nekterych testu (jako namespace, ...) zminit, ze jsme je vytvorili na zaklade zjisteni v prubehu vytvareni jinych testu.
  Testovane vlastnoti se ukazali jako casto objevujici a tedy dulezite.
  V uvodni kapitole se zminit, ze jsme neco vynechali (nesting, recursion), protoze jsou to extremni pirpady,
  ktere se nevyskytuji. Ale udelali jsme testy na veci, vyskoumene v prubehu testovani.
* Strana 48 -> vysvetleni "rdf" elementu pomoci footnote.
* Prinos je take vytvoreni ToXGene sablony pro RSS a dalsi
* Jeste by sla urcite udelat zajimava kategorie SVG, jen to okomentovat v praci.
* Moc jsme neresili xsl:include a xsl:import. To by mozna taky stalo za analyzu.
* Zminit se, ze nas program je mozno pak pouzit napriklad pro testovani (podobne jako PHPUnit)
  pri vytvareni XSLT sablon, aplikaci atd.
* Zminit se o GitHubu a ze na nem jsou tasky, na kterych by se dalo pokracovat dal.
  Taky to, ze to je teda otevreny projekt.
* V prubehu vytvareni testu, jsme samozrejmne obcas udelali chybu a neketere procesory se s nimy vyporadali lepe
  a nektere hure. Chtelo by to udelat analyzu toho, jak se jednotlive procesory vyporadavaji s error
  a jak je dokazi srozumitelne reportovat uzivateli.
* Napsat u ketereych testu, ze jsme predpokladali, ze processory sablony korektne zpracuji.
  Slo nam spis o rychlost a pamet. Nic mene, pokud by napriklad nekdo chtel vytvaret vlastni
  XSLT procesot, muse tyto jednoduche testy pouzit i pro testovani korektnosti implementace.
  Nebo pokud bychom chteli pridat nejaky novy XSLT procesor, muze to odhalit ventuelni zasadni problemy v implementaci.
* Nektere testy by sly vyresil jednoduzsi sablonou, ale jso o otestovani urcitych elementu apd.
  Napriklad "xsl:foreach" (nejdpis by slo resit transformaci lepe, ale jde o pouziti vetsiho mnozstvi
  elemnru xsl:foreach).
* Vetsina vytvorenych testu by mela prochazet. Jde nam u nich hlavne o rychlost a pamet
  (vyjmennovat je, nebo spis ktere nemusi projit).
  Pokud by nekdo pridal processor driver, pak by tyto testy mely projit.
* Az pobezim testy, tak vsechny programy vypnout, nic jineho nepoustet (a odpojit se od internetu -- tohle nebylo uplne vsude).
  Aby to nebylo ovlivneno zadnimy vlivy.
  "--repeating" nastavit klidne na nejakou vetsi hosnotu (10), aby ten prumer byl nejak rozumny.
* Sehnat testy XsltMark a pouzit je jako samostatnou sadu testu.
  Negenerovali by se, jen by se spustili.
  Poku by nemeli k sobe "expectedOutput", koukal bych jen na rychlost a vyuziti pameti.
  Pokud je nesezenu, tak napsat, ze nebylo mozne je sehnat, ale ze by je melo jit pouzit v nasem benchmarku.
* Nektere testy jsou zavysle na slozitosti a spravne implementaci XPath.
  To rozebirat nebudeme, to je velka samostatna kapitola. Proto jsme se znazili pouzit pouze jednoduche XPath.
  S temi by procesory nemeli mit problemy.
* Vetsina testu je parametrizovatelna. My pouzijeme nastaveni dle analyzy stazenych dokumentu.
  Je mozne si nechat vygenerovat testy s jinymy nastavenimy dle svych konkretnich potreb a spustit benchmark.
* Smarty bylo pouzito, protoze je primocarejsi na generovani pozadovanych sablon.
  Bylo by mozne pouzit i "XSLT driver", ale v nem by vytvareni sablon bylo hodne komplikovane.
  Neni problem ho vsak pridat.
  ToxGene jsme pouzili mene casto nex bylo zamysleno. Generovani  vstupniho XML i vystupniho XML opovidajiciho
  ocekavanemu vystupu nekdy bylo nemozne nebo prilis komplikovane. Smarty bylo pro tento ucel v mnoha pripadech pouzitelnejsi.
* Udelat si sablonu odstavece popisujici jednotlive testy.
  Kazdy by mel obsahovat
  	-> co sledujeme testujeme timto testem
  	-> co bylo problematicke a netipicke pri jeho vytvareni
  	-> jake jsou vysledky testu
* Popsat, ze jsme se pokouseli vychazet pri sestavovani testu z normy http://www.w3.org/TR/xslt
* Vygenerovany HTML report pak nekde zverejnit
  Dva reporty (pro Linux a Windows)
    - seznam testu skovavaci
       - kazdy nazev testu muze skovat/zobrazit tabulku
       - kliknuti na vse skovat, vse zobrazit
       - defaultne vse zobrazene
* Defaultni XML output je pouzit ve vetsine testech
* Generatory
  	ToxGene
		vyhody: staci zmenit seed a uz mam jina data, takze je vetsi moznost vytvoreni ruznych testu
		nevyhody: nekdy je dost slozite vytvorit pozadovana data (vstup + ocekavany vystup)
	Smarty
		vyhody: jednoducha primocara tvorba testu, lehke vytvirit kombinaci "vstup + ocekavany vystup"
		nevyhody: temer vse si musim vytvorit rucne a testy jsou mene variabilni
* Srovnat nejake testy, ktere maji "velke XSLT + male XML" vs. "male XSLT + velke XML"
   -> co bude rychlejsi a co zere vic pameti.
* Obecne me zajima srovnani rychlosti mezi processory pro jednotlive testy pro kategorie.
  Stejne tak pro typicky dokument.
  A navic napriklad srovnani vramci jedne sablony testu (=> vysledne testy) pro kazdy processor zvlast
  (rss-generator => rss-generatro-apply-templates vs. rss-generator-call-template)
* Navrhy na rozsireni (ukazalo se, ze to bude potreba az v prubehu, na zaactku nas to nenapadlo).
  Ted nejsou potreba (v testech nebyly tak ztezejni). Byly potreba jen malo a to se dalo vyresit rucne.
	* Navrh jak rosirit moznosti testu o ocekavani vice vystupu (stacilo by, aby odpovidal vystup aspon jednomu)
	  Je dulezite zachovat moznost nastavit jeden vystup pomoci atributu, kvuli zpetne kompatibilite.
		<test name="Test">
			<file input="input1">
				<output>expectedOutput11</output>
				<output>expectedOutput12</output>
			</file>
			<file input="input2" output="expectedOutput2" />
			<setting name="neco">123</setting>
		</test>
	* Navrh jak rosirit moznosti testu o chytani erroru
		<test name="Test">
			<file input="input1" output="expectedOutput1">
				<error>tento string chci aby tam byl</error>
				<error>nebo tento string</error>
			</file>
			<file input="input2" output="expectedOutput2" />
			<setting name="neco">123</setting>
		</test>
	* Konbinace ERROR a vice EXPECTED_OUTPUT -> bud jeden z vstupu nebo jeden z erroru
		<test name="Test">
			<file input="input1">
				<output>expectedOutput11</output>
				<output>expectedOutput12</output>
				<error>tento string chci aby tam byl</error>
				<error>nebo tento string</error>
			</file>
			<file input="input2" output="expectedOutput2" />
			<setting name="neco">123</setting>
		</test>
	* Jeste by to chtelo domyslet, kdyz chci napriklad aby error obsahoval string a zaroven jiny
	  (zatim je nastaveno na "nebo")
	* Kdyz bych jen ocekaval error, ale nezajima me jaky, tak prazdny retezec v erroru
		<test name="Test">
			<file input="input1" output="expectedOutput1">
				<error></error>
			</file>
			<file input="input2" output="expectedOutput2" />
			<setting name="neco">123</setting>
		</test>
	* Pokud ocekavam jeden error, muze to byt stejne jako output pouzito jako atribut.
	  Kdyz je error nemusi byt nastaven output.
		<test name="Test">
			<file input="input1" error="" /> --- musi vratit jakykoli error
			<file input="input2" error="error2" /> --- musi vratit error obsahujici error2
			<file input="input3" error="error3" output="expectedOutput3"/> --- musi vartit error obsahujici error3 nebo v poradku vygenerovat expectedOutput3
			<file input="input4" output="expectedOutput4" /> --- musi vygenerovat expectedOutput4
			<setting name="neco">123</setting>
		</test>
	* V textu vytvorit jeden ukazkovi priklad obsahujici vsechny moznosti a okomentovat tento navrh.
* sel by zkoumat MathML, jestli ma nejaka svoje specifika
* Licence:
  Dodelat ve vsech souborech licenci.
  Pokud mam nejake stazene soubory, pridat licenci k souboru, co tam ma byt (jako napriklad u DocBook).



TESTY:
------
Vytvorene: (jednotlive sekce asi budou odpovidat kapitolam)
----------
-----------------------------
---- FEATURES - ELEMENTS ----
-----------------------------
* element-value-of
	Nebudu delat -> je to hodne zavysle na XPath
	Ale "value-of" je pouzite prubezne v jinych testech, takze je vlastne pokrito dostatecne.
	(napriklad v "elements-template")
* elements-copy-of + elements-variable
  Dost zavysle na XPath, pouzito v testech ... stejny komentar jako u "element-value-of"
  U obojiho by bylo mozne dodelat specializovane testy
* element-choose
  Zahrnuje i elementy "when" a "otherwise"
  Bylo jesdnoduzsi pouzit smarty nez toxgene (s nim by to bylo prilis komplikovane).
  Short (with not presented (with otherwise)) vs. Long (with not presented (with otherwise)) -- stejne vystupy, ale ruzne narocne zpracovani
  (Short|Long) vs. (Short|Long) with not presented -- stejne vystupy, ale navic zbytecne "choose"
  (Short|Long) with not presented vs. (Short|Long) with not presented and otherwise -- podobne vystupy, ale navic zbytecne "otherwise"
* element-element
	Zahrnuje i element "attribute".
	Testuje
	   -> element "element"
	   -> vliv odsazeni XSLT na rychlost z pracovani a pouzitou pamet
* elements-foreach
  Obdoba "elements-choose" ... okomentovat asi dohromady
* elements-if
  Obdoba "elements-choose" ... okomentovat asi dohromady
* element-template(-common)
	Zahrnuje i dalsi elementy ("apply-templates", "with-param", "call-template", "param").
	"elements-template-procedural" vs "elements-template-noprocedural" - oba delaji to same jinou cestou
	   - srovnani rychlosti a vyuzite pameti vramci kazdeho procesoru
	Elements template - Empty
		=> libxslt 1.1.23 - PHP => vynechano <? ... ?>
		=> xsltproc 1.1.?? => nevygeneruje nic -> patrne to same
		  ---> proste kdyz nic neni na vystupu, bere to jako ze to neni nic --> je to OK?
		=> XT => pridal navic prazdnu radek
		  ---> to je vlastne OK
* element-text-(text|xml)
	Bylo potreba rozdelit na dva samostatne testy, generovani by bylo komplikovane (tohle je vyjmecny pripad).
	Testy co neprosli, jsou vlastne OK (EOL, radek navic na konci).
------------------
---- FEATURES ----
------------------
* typical
  ("format-number" bylo pouzito hlavne kvuli jednotnemu vystupu -> pokud nebude vsude fungovat, tak zrusit -- kouknout na normu, jake je defaultni nastaveni formatu)
  Odchylili jsme se jen v maximalni hloubce z 5 na 6, coz neni tak zasadni problem.
  Uspech je, ze jsme pouzili vsechny tipicke elementy najednou v relativne neumelem testu.
  		- max 10kB									-> ano
  		- max depth 5								-> ma 6 :-(
  		- if,choose,foreach - bez zanoreni	-> ano
  		- bez rekurze								-> ano
  		- output = default XML					-> ano
  		- fanout (avg 1, max 0-40)				-> ano avg = 1, max = 5; (5+0+0+1+1+3+1+0+0+0+1+3+1+0+1+0+2+0+0+5+0+0+0+0+4+1+1+1+1+0+0+0+0 / 33)
  		- 16 tipickych elementu					-> pouzite vsechny (ne sice v pomeru v grafu, ale to by nejspis neslo v jednom dokumentu)
  			- value-of
  			- text
  			- apply-templates
  			- when
  			- temaplte
  			- with-param
  			- if
  			- call-template
  			- attribute
  			- variable
  			- choose
  			- for-each
  			- param
  			- otherwise
  			- copy-of
  			- element
--------------------
---- CATEGORIES ----
--------------------
* RSS - generator
	- sleduju jak rychlost a pamet vuci jinym testum, tak mezi obema testy
	- typical -> tyhle zjistene vlastnoti napsat k popisu testu v praci
		- pouze jeden kanal (element "channel"), i kdyz by jich mohlo byt vic
		- version: 2.0=5
		- root: rss
		- template: match
		- pro vypis "items" => udelat 2 testy
			"foreach"=6
			"apply-templates select"=6
		- <xsl:output method="xml" encoding="utf-8" indent="yes"/> = prurez nejcasteji pouzitymi
		- generovat primo (ne pomoci xsl:element, xsl:attribute)
		- channel:
			*title (string / cteny: value-of)
			*link (cteny: value-of)
			*description (nejaky delsi string, cteny omoci value-of)
			@language (en) = 5
			pubDate (cteny: value-of) = 3
			generator (nejaky string) = 3
		- item:
			*title
			*link
			*description
			*pubDate (nekdy prazdne)
			@guid (obcas stejne jako link) -- vse ctene: value-of
			lang
* RSS - reader
	- typical
		- set output: xml=5, html=4, "nic"=1
		- real output: xml=1 ,html=11
		- omit-xml-declaration: yes=6, no=6 -- oboji
		- rss=8, rdf:RDF=1
		- match-(channel i item)=7 , match+foreach=3
		- "primo"=11, xsl:element=1
		- xsl:attribute=6 , "primo + {...}"=5 -- vyskouseno uz v "newsfeeds"
		- channel (porovnat s celkovim poctem dokumentu)
			@- title=9/12=75%
			@- description=5/12=41%
			@- link=4/14=33%
			- image=3/12=25%
		- item (porovnat s celkovim poctem dokumentu)
			@- link=12(3)/12=100%
			@- title=10(2)/12=83%
			@- description=6(3)/12=50%
			- pubDate=3/12=25%
			- "foreach--position()"=2/12=10%
			- category=1/12=8%
		- Saxon pridava do vygenerovaneho HTML nove radky. Ve vystupu to nevadi, diky tomu, ze to je HTML.
		  Ale jde o to co rika norma: je to povoleno (http://www.w3.org/TR/xslt#section-HTML-Output-Method)
		  Aby to nedelelo problem, pridali jsme indent="no" (i kdyz v analyzovanych datech bylo pouzito indent="yes")
	- newsfeeds.xslt --- pokus nepujde pouzit, tak skrtnou zminku v kategorii RSS
		- Generovane elementy napovidaji na vystup HTML, ale vystupem neni cele HTML.
		  Takze jde o soucast nejake vetsi XSLT sablony, ale v nasich stazenych sablonach nikde neni
		  'newsfeeds.xslt' vkladana pomoci "xsl:include" nebo "xsl:inport".
		  Ze se nejedna o celek, nam nevadi.
		  Proste vygenerujeme vystup a overime oproti ocekavanemu vystupu.
		  Soucasti 'newsfeeds.xslt' je i pouziti slozenych zavorek pro vyplneni hodnoty atributu
		  (viz http://www.w3.org/TR/xslt#dt-attribute-value-template)
		  Protoze to je jen cast finalniho vystupu, je pouzito 'omit-xml-declaration="yes"'.
		  Museli jsme pridat "output@encoding", jinak to dela problem s kontrolou obsahu.
		  Stejne tak dela problem i "output@indent".
		  Na kodovani a indent mame vlastni testy.
* GSA
	- template with default value
	- customer-onebox.xsl ... to jsme zakomentovali, protoze to neni tak zasadni
		vystup je vytvoren i tak
	- bylo potreba sehnat testovaci vstup (http://code.google.com/p/gsa-parser/source/browse/GSA/xslt/1.xml?r=2)
	- Vygenrovany vystup z XSLTPROC jsme pouzili jako "expectedOutput".
	  Vystupy se u jednotlivych procesoru lisi v drobnostech. Zjistovat jaky je skutecne ocekavany vystup by bylo prilis narocne vzhledem ke slozitocti sablony.
	  Jelikoz je vystup HTML, postaci nam se podivat na vygenerovany vystup "rucne".
	  Vsechny zvladli vygenerovat sabloblony vzasade vporadku. Az na:
	  		- Sabloztron -- vystup vygenerovat, ale zahlasil hodne Warningu (drobny problem)
	  		- XT - nevygenerovalo vubec nic -- velky problem -- testejm neprosel
	  		- krome MSXML 3 i 6 - vsechny ostatni procesory meli problem s vypsanim "ReportsÂ® is" .. vypsaly "ReportsĂ‚Â® is"
	  Sablona ma ale problem s kodovanim, coz muze byt pircina prblemu s "ReportsĂ‚Â® is". I kdyz nastavime <xsl:output encoding="UTF-8">,
	  vygenerovany vystup nema zadne kodovani. Pruzkum ukazal, ze klodovani si sablona resi sama, coz neni uplne idelani.
	  V kazdem pripade nezohledneni nastevenho kodovani, je chyba.
	  Ve vysledku je tedy vetsina procesoru pro GSA pouzitelne (krome XT), ale je nutne si vystup odladit (naprikald kodovani) pro konkretni pouziti.
* GraphML
	- random -> spring -> svg ... jednotlive vystupy pouzity jako vstupy pro dalsi
	- example -> spring -> svg ... ukazkovy graf pouzit jako stup a pak --""--
		http://graphml.graphdrawing.org/primer/graphml-primer.html#BCfile
	- posldoupnost prikazu
		- vygeneruju nahodny graf
			java -jar saxon.jar -o rndGraphGNM.xml empty.xml gnm.xsl
		- pridam do nej data o umisteni pro hezke vykresleni pomoci Spring metody
			java -jar saxon.jar -o rndGraphGNMWithData.xml rndGraphGNM.xml spring.xsl
		- pretransformuju graf do vykresneni SVG
			java -jar saxon.jar -o rndGraphSVG.xml rndGraphGNMWithData.xml graphml2svg.xsl
	- Oneco vis se otesuje i XPath a vyuziti XSLT na vypocty.
	- Nevyhoda -- potrebuje Javu na vypocty.
	- Problem s xmlns="http://graphml.graphdrawing.org/xmlns/graphml" -- bylo potreba odstranit, jinak nevracelo to co melo
		- zjitit proc ... mozna kvuli tomu, ze odkaz neexistuje, ale to by nemelo vadit
	- Zmena kodovani vystupu na UTF-8
	- xsltproc -- problem s version="2.0"
		-> nastavim na 1.0 a je to OK
		-> verzy testuje jiny test -> proto jsme prenastavili verzi na 1.0
	- Zjistene uskali -> problem s matematickycmi finkcemi -> pak je zavysliost na procesoru
* XGMML
	- typical (na zaklade 8 podobnych ze sranek)
	- !!! opravit odkaz 38 na http://www.cs.rpi.edu/research/groups/pb/punin/public_html/XGMML/XSL/XSL_BL/
	- do textu kapitoli o XGMML dopsat, ze toto neni sice zajimavy format, ale ukazal nam,
	  ze relativne vporadku dokazeme vyfiltrovat pozadovane soubory (jsou tam nejake navic, to projdeme rucne,
	  ale hlavne tam zadne nechybi), takze je to dalsi potvrzeni toho, ze jsme i u ostatnich kategorii,
	  nejspis provedli filtry vporadku.
	- pouzili jsme testovaci vstupni data ze stranek + ocekavany vystup (na strankach bylo, co ma XSLT sablona vytvorit)
	- pridan "xsl:output@encoding" a "xsl:output@indent" aby to nedelalo problemy (podobne jako u RSS-read-typical)
* RDF + RDFS - reader + generator
	- V prubehu zkoumani sablon jsme zjistili, ze sablony nejsou vuci ostatnim testum nejak zajimave,
      krome vetsiho mnozstvi pouziti nemaspace.
	  Jednak exituji rosireni RDF (OWL, Dublin Core, FOAF, ...), druhak rdf obecne ocekava vlastni namespace.
	- Proto nebudeme vytvaret zbytecne testy na RDF a RDFS, ale vytvorime specializovany test na namespace
	  (viz. odkaz na kapitolu)
	- Pokud by nekdo nutne potreboval, je mozne vytvorit specializovany test na RDF, RDFS, OWL, Dublin Core, ...

	** RDFS - reader
		- typical (na zaklade 6)
	** RDFS - generator
		- simple test
	** RDF - reader
		- pouze RDF
		- pouze RDF + HTML zacatek
		- RDF + jiny format
	** RDF - generator
		- "dostatek testu" (smarty generator)
	RDFS
		- je jich celkove malo --- vytvorim jeden test, kde se bude z jednoho ormatu prevadet do druhyho
		- klidne zkusm RDFS <--> HTML (napriklad v tabulce) ... treba neco jako ma parser na webu
		- pouzit - generator
			- rdfs:class
			- rdfs:subClassOf
			- rdfs:comment ?? opravu jen z RDFS
			- rdfs:isDefinedBy ?? co to je
			- rdfs:label ?? co to je
			- rdfs:range ?? co to je
			- rdfs:subPropertyOf
		- pouziti - reader
			- @rdf:id 50 na 50
			- vystup:HTML
			- <xsl:template match="/"> pro vypsani uvodu HTML
			- pro tridu/propertu/... vlastni sablona, ktera ji obali jako "<span><a>..." nebo "<h2> + <li> nebo <dt>"
			- budu muset vyuzit i rdf:property ... to asi defunuje property tridy
		- HTML tabulka
			| class | subClassOf |  | comment |
		- rdf:property ... PREDIKAT
			- rdfs:domain ... jake tridy je SUBJEKT, ketremu prirazujeme tento predikat
			- rdfs:range ... jake tridy je OBJEKT, ketremu prirazujeme tento predikat
	RDF
		Vytvorit vlastni sablonu + vstupni + vystupni data.
		Jen se kouknout, ktera varianta se pouziva + jestli s pouziva BAG, SEQ a ALT.
	-----
	RDF - pomoci vlastnich elementu:
	<rdf:rdf
		xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
		xmlns:[NAMESPACE]="[NAMESPACE_URI]"
	>
		<rdf:description rdf:about="[SUBJECT1]">
			<[NAMESPACE]:[PREDICAT1]>[OBJECT1]</[NAMESPACE]:[PREDICAT1]>
			<[NAMESPACE]:[PREDICAT2]>[OBJECT2]</[NAMESPACE]:[PREDICAT2]>
		</rdf:description>
		<rdf:description rdf:about="[SUBJECT2]">
			<[NAMESPACE]:[PREDICAT3]>[OBJECT3]</[NAMESPACE]:[PREDICAT3]>
			<[NAMESPACE]:[PREDICAT4]>[OBJECT4]</[NAMESPACE]:[PREDICAT4]>
		</rdf:description>
	</rdf>

	RDF - pomoci vlastnich elementu s atributem "resource":
	<rdf:rdf
		xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
		xmlns:[NAMESPACE]="[NAMESPACE_URI]"
	>
		<rdf:description rdf:about="[SUBJECT1]">
			<[NAMESPACE]:[PREDICAT1] rdf:resource="[OBJECT1]"/>
			<[NAMESPACE]:[PREDICAT2] rdf:resource="[OBJECT2]"/>
		</rdf:description>
		<rdf:description rdf:about="[SUBJECT2]">
			<[NAMESPACE]:[PREDICAT3] rdf:resource="[OBJECT3]"/>
			<[NAMESPACE]:[PREDICAT4] rdf:resource="[OBJECT4]"/>
		</rdf:description>
	</rdf>

	RDF - pomoci vlastnich atributu:
	<rdf:rdf
		xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
		xmlns:[NAMESPACE]="[NAMESPACE_URI]"
	>
		<rdf:description rdf:about="[SUBJECT1]"
			[NAMESPACE]:[PREDICAT1]="[OBJECT1]"
			[NAMESPACE]:[PREDICAT2]="[OBJECT2]"
		/>
		<rdf:description rdf:about="[SUBJECT2]"
			[NAMESPACE]:[PREDICAT3]="[OBJECT3]"
			[NAMESPACE]:[PREDICAT4]="[OBJECT4]"
		/>
	</rdf>
	-----
	match="/"
		html...
	match="rdfs:Class"
		apply-templates select="rdfs:label" ... test kde to je a test kde to neni ... mozna ... priste to jde oddelat a hotovo
		apply-templates select="rdfs:comment"
		domain
		range

	match="rdfs:label"
	match="rdfs:comment"
	match="rdfs:domain"
	match="rdfs:range"
	-----
* Namespace
	- namesapce by sli urcite testovat vic, ale tohle odpovida jejich pouziti v datech, proto nam to staci
	- aliasy
		- Vetsina procesoru dela chybu (bud zobrazuje oba namesapce nebo misto ciloveho prefixu pouziva vychozi).
		  Neni to moc velky prohresek (vysledek je funkcni). Ale neni to podle normy.
			- http://www.w3.org/TR/xslt#section-Creating-Elements-and-Attributes
				- Thus, the "stylesheet-prefix" attribute specifies the namespace URI that will appear in the stylesheet,
				  and the "result-prefix" attribute specifies the corresponding namespace URI that will appear in the result tree.
				- stylesheet-prefix = namespace URI pouzite v "sablone"
				- result-prefix = namespace URI pouzite v "generovanem vysledku"
				-- plati to i pro 2.0 -- http://www.w3.org/TR/xslt20/#dt-literal-namespace-uri
					- ...is replaced by the prefix indicated by the result-prefix attribute of the xsl:namespace-alias declaration.
			- kopirovani nastavenych namespace -> jen ten z "result-prefix"
		rename:
			- zkouma pouziti jineho prefixu pro XSLT nez je v XML
* Encoding
  V prubehu testu jsme s tim meli probelm, proto jsme se rozhodli to otestovat.
	- musim vyresit kodovani v Controloru
	- odkaz na normu http://www.w3.org/TR/xslt#section-XML-Output-Method
		- musi respektovat utf-8 a utf-16
		- pokud nastavim jine, musi pouzit, nebo zahlasit error nebo pouzit utf-8 nebo utf-16
		- kdyz nic nenastavim, musi pouszit utf-8 nebo utf-16
			- asi neni povinne pro default uvadet encoding v deklaraci
  - vysledky --> JESTE DOZKONTROLOAVT
	- XT -> ma problem s prectenim vstupniho kodovani jineho nex utf-8 a utf-16
		 -> je to problem SAX XML parseru, mohl by byt pouzit jiny, ale na strankach je odkaz na tento,
			takze povazujeme za chybu
	- kodovani zadano -> krome XT je to vporadku
	- default -> nektere nastvi utf-8, nektere utf-16, nektere nic ale vse je OK
* output-html --> v nekterych testech pouzivam a neni s tim problem, takze OK
* size --> vetsina testu splnuje (mohli by se v budoucnu dodelat specializovane testy)
  Moznost nastavit jakou chci priblizne velikost vystupu a podle toho mi to vygeneruje test.
* xsl:stylesheet -- xsl:version
  V prubehu testu jsme s tim meli probelm, proto jsme se rozhodli to otestovat.
  Test na verzy XSLT. Jeden bez elementu v 2.0 a jeden s elementy z 2.0.
  Zkusit pouzit elementy, ktere se objevili aspon v nejakych stazenych datech (viz graf).
	-> xsltproc neumi XSLT 2.0 --> nedostatek
	-> (ale podotkneme, ze libxslt (ze ktere xsltproc vychazi) jej umi)
	-> Zkusili jsme cvicne prazdny XSLT a jeden s elementem z 2.0 vyskytujici se nejvice
	   "output-character" (jestli procesory nekecaji a skutecne umi 2.0).
	   Pro kompletni test 2.0 by to chtelo vic testu.
	   V datech ale 2.0 moc pouzito nebylo, takze nam to staci takhle.
  Prazdne XSLT delalo problem jen "xsltproc". Ale aspon nahlasil, ze numi 2.0.
  Ostatni to u prazdneho nenahlasili, ale nas zkusebni element "output-character" umi jen "Saxon HE 9.4.0.2".
  Ostatni jej igorovali. Takze jen u nej muzeme predpoklad, ze umi 2.0.
  U "xsltproc" aspon ocenime, ze zahlasi error, ze neumi 2.0. Ostatni by to meli zahlasit, pokud jej neumi.
  Jeste Sablotron dal vedet, ze neumi atribut @use-character-maps. Ostatni tise ignorovali nastaveni verze 2.0
  a neznalost elementu "output-character".
  Nefunguje "libxslt 1.1.23 - PHP". JE spatne, ze pri "importStylesheet" nezahlasi, ze neumi "xsl:character-map"
  a spadne az pri pokusu o transformaci s errorem, ze nema nastavenou sablonu pro trasformaci.
* DocBook - generator
	- base test
	- nebudu delat zadny test, popsat to i v Categor podsekci
	- nemelo by to cenu, delat neco jen na zaklade jedne sablony
	- podobne to okomentovat asi i u RDF a RDFS
* DocBook - reader
  Upravit pokec o DocBook. Rict, ze vetsina dokumentu je z http://docbook.sourceforge.net/release/xsl/1.76.1/.
  Vlastne jsou to ty sablony co jsme nasli (jednotlive casti).
  Je to sada XSLT sablon urcenych pro transformaci urcitych typu dokumentu. V textech muzeme tedy rovnou vychazet z nich.
  Ukazeme na tom, jak se da udelat test primo bez sablony (do /Tests/docbook nakopiruju ze stranek potrebnou
  hromadu XSLT sablon + pridam __params.xml + pridam vstup + ocekavany vystup (museli jsme vytvorit)).
  Dobry na tom testu je, ze obsahuje hodne includu a je to vcelku velka XSLT.
  Takze zjistime jaky to ma vliv na memory a CPU narocnost.
  Program by sel rozsirit na to, ze XSLT vygeneruje vice souboru. Testnout by to slo prave treba Docbook sablonamy "htmlhelp".
  Stazeno z http://sourceforge.net/projects/docbook/files/docbook-xsl/1.76.1/
  Testy:
	- neco je OK, neco ne
	- nahodne se generuje #id123456 -> museli jsme tridat do testi id elementu, aby byl test deterministicky
	- ale presto to generuje HTML a s tim je problem (viz kapitola kde to rozeberu)
	- vysledky:
		"libxslt 1.1.23 - PHP" --> spatne
		"MSXML 3.0" --> error
		"MSXML 6.0" --> error
		"Sablotron" --> error
		"Saxon 6.5.5" --> asi OK
		"Saxon HE ..." --> asi OK (ten nas aspon upozronil, ze se neco vkladame vicekrat)
		"XT" --> asi OK
		"Xalan" --> asi OK
		"xsltproc 1.1.23" --> spatne
		"xsltproc 1.1.26" --> OK
* include
  Specialni test na xsl:include. Inspirovano DocBook. Samotny DocBook nefunguje vsude.
  Aspon otestujeme samotne include. DocBook by mohlo byt inspiraci pro dalsi testy.
  Problem ma jen "MSXML 6.0", defaultne kvuli bezpecnosti nedovoluje.
  Je potreba povolit explicitne http://msdn.microsoft.com/en-us/library/windows/desktop/ms763800(v=vs.85).aspx -- "Loading External Files Is Prohibited by Default"
  Zminit, ze tento test musel byt (stejne jako DocBook) udelan primo,
  protoze pres sablony by se tam nedostali "include1.xslt" a "include2.xslt".
  Dalsi mozne rozsireni, aby bylo mozne pridat do sablon soubory, ketere se includuji z sablon
  a nejsou primo odkazovany v tastu jako "input" nebo "expectedOutput".



Mozna udelat, kdyz bude cas:
----------------------------
-- Co neudelam, zminit, ze by se mohlo udelat.
-- Stejne tak u testu co mam nahore okomentovane, ze neni potreba udelat (napriklad HTML),
   tak rict, ze by se mohli udelat specializovane testy.
* empty vs. big input XML
  		--IN-- vs. --XSLT--
  		empty      big (viz elements-element)
  		big        big (??????)
  		big        emtpy (jen copy outputu pomoci par jednoduchych sablon)
* nesting
  Nemelo by byt zadne, coz je splneno ve vetsine testech.
* recursion
  Nemelo by byt zadne, coz je splneno ve vetsine testech.
  Napad na test: vystup v HTML - stromova struktura pomoci <ul> a <li>
* max-depth
  Parametrizovatelny test, kde si nastavim pozadovanou hloubku.
  Pouzit nastaveni pro 5, 3 a 10 (viz graf).
  Vetsina testu ma maximalni hloubku cca mezi 3-5.
* output-indent
  Tetuje zohledneni odsazeni vystupniho XML podle "<xsl:output indent="yes" ... />"
  Nejspis bude nutne zkontrolovat rucne, protoze trida Controlor nam automaticky normalizuje porovnavane XML
  Indent muze byt v ruznimy procesory chpan ruzne (mezera, dve mezery, tabulator, dalsi bile znaky (odradkovani mezi templates) => nutno porovnar rucne)
* XPath
  Velka kapitola, to by mozna vydalo na samostatnou praci. Je mozno pouzit nas program pro testy.
* fan-out --> specializovany test, ktery by bylo mozno dodelat
  Test, kde bude mozne urcit velikost fan-out
  Podbne jako v "elements-element" => "fan-out-3", "fan-out-10" a "fan-out-40"
  -> nastvit jestli chci z "xsl:element", "xsl:attribute", "xsl:tmpalte", "xsl:choose"
  Vetsina testu splnuje hlavni rozmezi mezi 3-6 (viz graf).
  Tohle je specializovany test.






